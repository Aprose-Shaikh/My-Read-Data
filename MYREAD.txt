

Java Interview Preparation Tips 
Part 1: Core Java Interview Questions 
Part 2: JDBC Interview Questions 
Part 3: Collections Framework Interview Questions 
Part 4: Threading Interview Questions 
Part 5: Serialization Interview Questions 
Part 6: Classpath Related Questions 
What is immutable object in Java? Can you change values of a immutable object?

A Java object is considered immutable when its state cannot change after it is created. Use of immutable objects is widely accepted as a sound strategy for creating simple, reliable code. Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state. java.lang.String and java.lang.Integer classes are the Examples of immutable objects from the Java Development Kit. Immutable objects simplify your program due to following characteristics : 

Immutable objects are simple to use test and construct. 
Immutable objects are automatically thread-safe. 
Immutable objects do not require a copy constructor. 
Immutable objects do not require an implementation of clone. 
Immutable objects allow hashCode to use lazy initialization, and to cache its return value. 
Immutable objects do not need to be copied defensively when used as a field. 
Immutable objects are good Map keys and Set elements (Since state of these objects must not change while stored in a collection). 
Immutable objects have their class invariant established once upon construction, and it never needs to be checked again. 
Immutable objects always have "failure atomicity" (a term used by Joshua Bloch) : if an immutable object throws an exception, it's never left in an undesirable or indeterminate state. 

How to create a immutable object in Java? Does all property of immutable object needs to be final?

To create a object immutable You need to make the class final and all its member final so that once objects gets crated no one can modify its state. You can achieve same functionality by making member as non final but private and not modifying them except in constructor. Also its NOT necessary to have all the properties final since you can achieve same functionality by making member as non final but private and not modifying them except in constructor. 

What is difference between String, StringBuffer and StringBuilder? When to use them?

The main difference between the three most commonly used String classes as follows. 

StringBuffer and StringBuilder objects are mutable whereas String class objects are immutable. 
StringBuffer class implementation is synchronized while StringBuilder class is not synchronized. 
Concatenation operator "+" is internally implemented by Java using either StringBuffer or StringBuilder. 
Criteria to choose among String, StringBuffer and StringBuilder 
If the Object value will not change in a scenario use String Class because a String object is immutable. 
If the Object value can change and will only be modified from a single thread, use a StringBuilder because StringBuilder is unsynchronized(means faster). 
If the Object value may change, and can be modified by multiple threads, use a StringBuffer because StringBuffer is thread safe(synchronized). 

Why String class is final or immutable?

It is very useful to have strings implemented as final or immutable objects. Below are some advantages of String Immutability in Java 

Immutable objects are thread-safe. Two threads can both work on an immutable object at the same time without any possibility of conflict. 
Security: the system can pass on sensitive bits of read-only information without worrying that it will be altered 
You can share duplicates by pointing them to a single instance. 
You can create substrings without copying. You just create a pointer into an existing base String guaranteed never to change. Immutability is the secret that makes Java substring implementation very fast. 
Immutable objects are good fit for becoming Hashtable keys. If you change the value of any object that is used as a hash table key without removing it and re-adding it you will lose the object mapping. 
Since String is immutable, inside each String is a char[] exactly the correct length. Unlike a StringBuilder there is no need for padding to allow for growth. 
If String were not final, you could create a subclass and have two strings that look alike when "seen as Strings", but that are actually different. 

Is Java Pass by Reference or Pass by Value?

The Java Spec says that everything in Java is pass-by-value. There is no such thing as "pass-by-reference" in Java. The difficult thing can be to understand that Java passes "objects as references" passed by value. This can certainly get confusing and I would recommend reading this article from an expert: http://javadude.com/articles/passbyvalue.htm Also read this interesting thread with example on StackOverflow : Java Pass By Ref or Value

What is OutOfMemoryError in java? How to deal with java.lang.OutOfMemeryError error?

This Error is thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. Note: Its an Error (extends java.lang.Error) not Exception. Two important types of OutOfMemoryError are often encountered 

java.lang.OutOfMemoryError: Java heap space 
The quick solution is to add these flags to JVM command line when Java runtime is started: 
view plaincopy to clipboardprint?
-Xms1024m -Xmx1024m   
-Xms1024m -Xmx1024m 
java.lang.OutOfMemoryError: PermGen space 
The solution is to add these flags to JVM command line when Java runtime is started: 
view plaincopy to clipboardprint?
-XX:+CMSClassUnloadingEnabled-XX:+CMSPermGenSweepingEnabled  
-XX:+CMSClassUnloadingEnabled-XX:+CMSPermGenSweepingEnabled
Long Term Solution: Increasing the Start/Max Heap size or changing Garbage Collection options may not always be a long term solution for your Out Of Memory Error problem. Best approach is to understand the memory needs of your program and ensure it uses memory wisely and does not have leaks. You can use a Java memory profiler to determine what methods in your program are allocating large number of objects and then determine if there is a way to make sure they are no longer referenced, or to not allocate them in the first place. 

What is the use of the finally block? Is finally block in Java guaranteed to be called? When finally block is NOT called?

Finally is the block of code that executes always. The code in finally block will execute even if an exception is occurred. Finally block is NOT called in following conditions 

If the JVM exits while the try or catch code is being executed, then the finally block may not execute. This may happen due to System.exit() call. 
if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues. 
If a exception is thrown in finally block and not handled then remaining code in finally block may not be executed. 

Why there are two Date classes; one in java.util package and another in java.sql?

From the JavaDoc of java.sql.Date: 

A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value. A milliseconds value represents the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT. To conform with the definition of SQL DATE, the millisecond values wrapped inside a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero.
Explanation: A java.util.Date represents date and time of day, a java.sql.Date only represents a date (the complement of java.sql.Date is java.sql.Time, which only represents a time of day, but also extends java.util.Date).

What is Marker interface? How is it used in Java?

The marker interface is a design pattern, used with languages that provide run-time type information about objects. It provides a way to associate metadata with a class where the language does not have explicit support for such metadata. To use this pattern, a class implements a marker interface, and code that interact with instances of that class test for the existence of the interface. Whereas a typical interface specifies methods that an implementing class must support, a marker interface does not do so. The mere presence of such an interface indicates specific behavior on the part of the implementing class. There can be some hybrid interfaces, which both act as markers and specify required methods, are possible but may prove confusing if improperly used. Java utilizes this pattern very well and the example interfaces are 

java.io.Serializable - Serializability of a class is enabled by the class implementing the java.io.Serializable interface. The Java Classes that do not implement Serializable interface will not be able to serialize or deserializ their state. All subtypes of a serializable class are themselves serializable. The serialization interface has no methods or fields and serves only to identify the semantics of being serializable. 
java.rmi.Remote - The Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine. Any object that is a remote object must directly or indirectly implement this interface. Only those methods specified in a "remote interface", an interface that extends java.rmi.Remote are available remotely. 
java.lang.Cloneable - A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instances of that class. Invoking Object's clone method on an instance that does not implement the Cloneable interface results in the exception CloneNotSupportedException being thrown. 
javax.servlet.SingleThreadModel - Ensures that servlets handle only one request at a time. This interface has no methods. 
java.util.EvenListener - A tagging interface that all event listener interfaces must extend. 
The "instanceof" keyword in java can be used to test if an object is of a specified type. So this keyword in combination with Marker interface can be used to take different actions based on type of interface an object implements.



Why main() in java is declared as public static void main? What if the main method is declared as private?

Public - main method is called by JVM to run the method which is outside the scope of project therefore the access specifier has to be public to permit call from anywhere outside the application static - When the JVM makes are call to the main method there is not object existing for the class being called therefore it has to have static method to allow invocation from class. void - Java is platform independent language therefore if it will return some value then the value may mean different to different platforms so unlike C it can not assume a behavior of returning value to the operating system. If main method is declared as private then - Program will compile properly but at run-time it will give "Main method not public." error. 



The only difference between experienced and inexperienced software developers is that the experienced ones realize when they're making a mistake. 

Can you think of a questions which is not part of this post? Please don't forget to share it with me in comments section & I will try to include it in the list. 
You might like: 5 Killer Things You Can Do To Get Noticed and Hired by Google, Apple or Microsoft  25 Best Software For Web Design and Development You Must Have As A Designer  24 Collections Framework Interview Questions & Answers for Java developers  5 Best Core Java Books you must read as a developer  10 Reasons Why Develop for Android Platform First  10 Reasons Why Develop for Android Platform First  5 Best Core Java Books you must read as a developer  24 Collections Framework Interview Questions & Answers for Java developers  25 Best Software For Web Design and Development You Must Have As A Designer  5 Killer Things You Can Do To Get Noticed and Hired by Google, Apple or Microsoft 
Recommended by Posted by Sachin FromDev at 2/12/2012 
Labels: Interview, Tips 61 comments:
Arulkumaran.KFebruary 12, 2012 at 11:22 PM
Good questions and answers. I have covered around 650 Java JEE Interview questions with detailed answers with lots of diagrams and code snippets at http://java-success.blogspot.com.



The classpath is the location where the Java Virtual Machine search for user-defined classes, packages and resources in any Java program. Below is a list of some java interview questions on CLASSPATH that may give you an edge over others in your next Java interview.


Java Interview Preparation Tips 
Part 1: Core Java Interview Questions 
Part 2: JDBC Interview Questions 
Part 3: Collections Framework Interview Questions 
Part 4: Threading Interview Questions 
Part 5: Serialization Interview Questions 
Part 6: Classpath Interview Questions 

Why Java uses Classpath parameter or environment variables?
In a Java class import statements are used to access other classes.
You also do a wild card import like org.fromdev.* on your java file.
In such cases, It will become very impractical/slow for the Java Virtual Machine to search for classes in every file/folder on a machine, therefore you can provide the Java Virtual Machine with a list of places to look. This is done by putting folder and jar files on your classpath.

Environment variables in general are a set of dynamic name value pair that can be used by processes to decide the behavior based on a system. These are supported by all modern operating systems. 

The CLASSPATH variable is a Java way to tell the possible locations of user classes or jar files for a Java application. Since each user/computer may choose to have classes in different location its best to have custom locations configured in Classpath variable. 

In case you have not set the classpath environment variable, the default value is used as the "." (current directory). That means, the current directory is searched. 





When does Java read values of Classpath environment variable?
Java uses the CLASSPATH environment variable to read the classes and libraries from file system. This variable is used by all JDK Tools and Extension including Java Compiler (javac) and JRE(java) use this variable to locate the dependent user classes and jar files to perform specific tasks. 

Java Compiler uses it to locate the dependent user classes and jar files to compile Java source files. 

Java Run-time Environment (JRE) uses the classpath variable to identify the location of files to be loaded for the run-time dependencies (e.g. classes and jar files) of java program. 


How to set Java Classpath on Windows, Unix, Linux and Mac?

Setting CLASSPATH on Windows XP
Follow below steps on Windows XP to set Java CLASSPATH

Right-click My Computer, and then click Properties. 
Click the Advanced tab. 
Click Environment variables. 
Click one the following options, for either a user or a system variable 
Click New to add a new variable name and value. 
Enter Variable name as CLASSPATH 
enter all directories and jar files separated by semicolon. (e.g. c:\dir1;c:\dir2;c:\dir3\abc.jar) 


Setting CLASSPATH on Windows 7
Click Start 
Then right-click on Computer, 
select Properties 
click Select Advanced System Settings tab. 
click the Environment Variables button. 


Setting CLASSPATH on Unix, Linux and Mac

Use export command to set the CLASSPATH environment variable in your system.

export CLASSPATH=/path/to/dir1:/path/to/dir2:path/to/abc.jar



How do I check the CLASSPATH variable is set in my machine?

Checking CLASSPATH on Windows
To check CLASSPATH variable is set on Microsoft Windows, run following command on command prompt 

C:> echo %CLASSPATH% 


If CLASSPATH variable is not set you will see %CLASSPATH% on windows system.


Checking CLASSPATH on Unix, Linux or Mac 
To check CLASSPATH variable is set on Unix/Linux/Mac run following command on shell 


$ echo $CLASSPATH

If CLASSPATH variable is not set you will see CLASSPATH: Undefined variable error on Unix/Linux/Mac systems.


How to set Multiple Jar Files in Java Classpath
Java versions Older then Java 6 does not support wildcard characters. Setting Multiple jars using wildcard in Java classpath are allowed in Java 6 and later versions. 

For example, to specify all jar files in a directory "lib" the classpath entry should look like this 

lib/*

The wildcard entry (*) in classpath value will match only jar files NOT class files. To match both class files and JAR files in a same directory lib, you need to specify both values as shown below



Setting Multiple Jars in Classpath on Windows
Windows environment variable values are separated by semicolon, therefore you classpath entry would look like this

lib/*;lib 


Setting Multiple Jars in Classpath on Unix, Linux or Mac
Unix environment variable values are separated by colon, therefore you classpath entry would look like this

lib/*:lib


Older version of Java
In older version of Java(older than Java 6), each jar file needs to be specified in the classpath. It can be a tedious and erroneous task if you are using many third party libraries. 


What is the difference between NoClassDefFoundError and ClassNotFoundException? When NoClassDefFoundError and ClassNotFoundException are thrown?


NoClassDefFoundError and ClassNotFoundException are very closely related and often confused with each other by many developers. Below is the description of each from the Java API Specifications



ClassNotFoundException


Thrown when an application tries to load in a class through its string name using:

The forName method in class Class. 
The findSystemClass method in class ClassLoader. 
The loadClass method in class ClassLoader. 
but the definition of the class with the specified name could not be found due to following reasons

The specified name class does not exist. 
The specified name class is not in the classpath 
The specified name class is not visible to the classloader. 


NoClassDefFoundError
Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.

The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.

Key Differences 
The NoClassDefFoundError is thrown when the source was successfully compiled, but during runtime, the required class files were not found. This may be a case when some dependency jar files were not included or not in classpath.

A ClassNotFoundException is thrown when the reported class is not found by the ClassLoader or not visible to the Classloader. 


Another important distinction between these two is, NoClassDefFoundError is a sub class of java.lang.Error and the ClassNotFoundException is a subclass of java.lang.Exception.


NoClassDefFoundError is a critical error for JVM since its having problems finding a class it expected to find. 

On the other hand, the ClassNotFoundException is an Exception. Use of reflection api can be error-prone and there is no compile-time check to validate reflection call is loading right classes, so there can be situations when some classes may not be found.


Some scenario when ClassNotFoundException may occur

Scenario 1 (Use of reflection) - You will see ClassNotFoundException when you are using reflection to load classes at runtime, and the class you are trying to load does not exist or not in classpath.

Scenario 2 (Multiple Classloaders being used) - You will see ClassNotFoundException when a class is being loaded from another class which was already loaded in a parent classloader and the class from the child classloader is not visible.


How can we include Jar within a Jar in java classpath?
There is no easy way to do this in current java versions. There are 2 alternatives to deal with this problem using third party libraries



Use Jar class loader library
The JarClassLoader library provides you the feature of loading resources from a top JAR and from JARs inside the top JAR.


Explode and combine into one jar 
Instead of trying to bundle jar file inside jar you can explode all required jars and re-bundle them as one jar using following two libraries 

The first is One-Jar, which uses a special classloader to allow the nesting of jars. 
The second is UberJar, (or Maven Shade Plugin), which explodes the included libraries and puts all the classes in the top-level jar. 

How to read a file from CLASSPATH in java?
This can be done in two simple ways 

Using ClassLoader.getResourceAsStream

This method can be used to load any file from CLASSPATH 


view plaincopy to clipboardprint?
InputStream in =this.getClass().getClassLoader().getResourceAsStream("MyFile.txt");  
InputStream in =this.getClass().getClassLoader().getResourceAsStream("MyFile.txt");


Using Class.getResourceAsStream
This method can be used to load files using relative path to the package of the class 


view plaincopy to clipboardprint?
InputStream in =this.getClass().getResourceAsStream("SomeTextFile.txt");  
InputStream in =this.getClass().getResourceAsStream("SomeTextFile.txt");

This method can also be used to load any files from CLASSPATH by prefixing a "/" 

How to find which jar file is being used by Java run-time?

On Windows 

You need use below windows program Process Explorer that lets you see which files are open for a particular process or program



On Unix, Linux or Mac 

It can be done using lsof command. lsof is one of my favorite and useful java debugging commands on Unix. Below is the syntax for using this command - 

view plaincopy to clipboardprint?
lsof -p [pid]  
lsof -p [pid]


How to find the load location of a Java class file at run-time?
There are two ways to find it

Using Classloader
Below code snippet can be used to find the location of java class com.fromdev.MyClass
this.getClass().getClassLoader().getResource("com/fromdev/MyClass.class")

Using Protection Domain
We can use this to find the exact location a jar file containing the class JVM is using

clazz.getProtectionDomain().getCodeSource().getLocation()





How Java handles Two classes with same name in classpath

If I have two classes with same name say MyClass.java in two different jar in my classpath which one will be picked up by JVM , is there anyway I can suggest JVM to pick a specific one ? 

Java interpreter loads classes based on the order they are specified in the CLASSPATH variable. 

For example, lets say this is your classpath variable value 
C:\Project\Dir1;C:\Project\Dir2

The Java interpreter will first look for MyClass class in the directory C:\Project\Dir1. Only if it doesn't find it in that directory it will look in the C:\Project\Dir2 directory.

How to Add A Jar File To Java Load Path At Run Time
This can done by use of URLClassloader. A sample implementation of this code is shown below

import java.net.URL;   
import java.net.URLClassLoader;   
  
public class SimpleJarLoader {   
  
 public static void main(String args[]) {   
  if (args.length < 2) {   
   System.out.println("Usage: [Class name] [Jar Path]");   
   return;   
  }   
  try {   
   System.out.println("Trying to load the class...");   
   Class.forName(args[0]);   
  } catch (Exception ex) {   
   System.out.println("Not able to load class..." + args[0]);   
  }   
  
  try {   
   String url = "jar:file:/" + args[1] + "!/";   
   URL urls[] = { new URL(url) };   
   URLClassLoader cl = new URLClassLoader(urls,   
     SimpleJarLoader.class.getClassLoader());   
   System.out.println("Looking into jar... " + url);   
   cl.loadClass(args[0]);   
   System.out.println("Woohoo....I found it");   
  } catch (Exception ex) {   
   System.out.println("Oops...Still cant find the jar");   
   ex.printStackTrace();   
  }   
 }   
}  
import java.net.URL;
import java.net.URLClassLoader;

public class SimpleJarLoader {

 public static void main(String args[]) {
  if (args.length < 2) {
   System.out.println("Usage: [Class name] [Jar Path]");
   return;
  }
  try {
   System.out.println("Trying to load the class...");
   Class.forName(args[0]);
  } catch (Exception ex) {
   System.out.println("Not able to load class..." + args[0]);
  }

  try {
   String url = "jar:file:/" + args[1] + "!/";
   URL urls[] = { new URL(url) };
   URLClassLoader cl = new URLClassLoader(urls,
     SimpleJarLoader.class.getClassLoader());
   System.out.println("Looking into jar... " + url);
   cl.loadClass(args[0]);
   System.out.println("Woohoo....I found it");
  } catch (Exception ex) {
   System.out.println("Oops...Still cant find the jar");
   ex.printStackTrace();
  }
 }
}
You can run this code by below command. (Make sure to use forward slash "/" as directory separator.) 
java SimpleJarLoader org.springframework.core.SpringVersion C:/spring.jar
The output is like this 
view plaincopy to clipboardprint?
Trying to load the class...   
Not able to load class...org.springframework.core.SpringVersion   
Looking into jar... jar:file:/C:/spring.jar!/   
Woohoo....I found it  
Trying to load the class...
Not able to load class...org.springframework.core.SpringVersion
Looking into jar... jar:file:/C:/spring.jar!/
Woohoo....I found it

Why calling System.setProperty() does not affect the classpath at run-time?
You can easily set any system properties in java using System.setPropoerty method, However it may not have any effect in case of CLASSPATH property. This is mainly because the Java system class loader is initialized very early in the JVM startup sequence. The class loader copies the classpath into its own data structures, and the classpath property is not read again. Therefore changing it after its already copied does not affect anything. There are mainly two reasons for this - First most important reason is security. You do not want a malicious code change the classpath at runtime and load some unwanted classes. Second reason is performance, since reading the classpath every-time its needed may not be efficient. 

How to Add A Jar File To Java System Classpath At Run-time?
This can be done by using a simple reflection API hack as demonstrated in below sample code. This example assumes you have a file "c:/Sample.txt" that is not already in class path and at run-time c:/ is added the System classpath and then Sample.txt is made available. 

view plaincopy to clipboardprint?
import java.io.File;   
import java.io.InputStream;   
import java.lang.reflect.Method;   
import java.net.URL;   
import java.net.URLClassLoader;   
  
public class HackJavaClasspath {   
  
 public static void addURL(URL url) throws Exception {   
  URLClassLoader cl = (URLClassLoader) ClassLoader   
    .getSystemClassLoader();   
  Class clazz = URLClassLoader.class;   
  
  Method method = clazz.getDeclaredMethod("addURL",   
    new Class[] { URL.class });   
  method.setAccessible(true);   
  method.invoke(cl, new Object[] { url });   
 }   
  
 public static void main(String[] args) throws Exception {   
  //Add c: to the classpath   
  addURL(new File("c:/").toURI().toURL());   
  //Now load the file from new location   
  InputStream in = Thread.currentThread().getContextClassLoader()   
    .getResourceAsStream("Sample.txt");   
  System.out.println(in.available());   
  
 }   
}  
import java.io.File;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;

public class HackJavaClasspath {

 public static void addURL(URL url) throws Exception {
  URLClassLoader cl = (URLClassLoader) ClassLoader
    .getSystemClassLoader();
  Class clazz = URLClassLoader.class;

  Method method = clazz.getDeclaredMethod("addURL",
    new Class[] { URL.class });
  method.setAccessible(true);
  method.invoke(cl, new Object[] { url });
 }

 public static void main(String[] args) throws Exception {
  //Add c: to the classpath
  addURL(new File("c:/").toURI().toURL());
  //Now load the file from new location
  InputStream in = Thread.currentThread().getContextClassLoader()
    .getResourceAsStream("Sample.txt");
  System.out.println(in.available());

 }
}

Running this java class prints the number of bytes available. This indicates the file is available for further processing. 
How to get a list of resources from a directory in Java classpath?
You can use Reflections library for doing this. Reflections is a open source Java library. It scans Java classpath and indexes it with metadata. This library allows you to query the classpath at runtime and can be very handy for many run-time reflection code needs. 

Can you think of more topics that are not part of this post? Feel free to share it with us in comments & we will try to improve this article. Hopefully making it best resource for future reference. 

Difference between PATH and CLASSPATH in Java
Here are some of the common difference between PATH vs CLASSPATH in Java :

1)Main difference between PATH and CLASSPATH is that  PATH is an environment variable which is used to locate JDK binaries like "java" or "javac" command used to run java program and compile java source file. On the other hand CLASSPATH environment variable is used by System or Application ClassLoader to locate and load compile Java bytecodes stored in .class file.

2) In order to set PATH in Java you need to include JDK_HOME/bin directory in PATH environment variable while in order to set CLASSPATH in Java you need to include all those directory where you have put either your .class file or JAR file which is required by your Java application.

3) Another significant difference between PATH and CLASSPATH is that PATH can not be overridden by any Java settings but CLASSPATH can be overridden by providing command line option -classpath or -cp to both "java" and "javac" commands or by using Class-Path attribute in Manifest file inside JAR archive.

4) PATH environment variable is used by operating system to find any binary or command typed in shell, this is true for both Windows and Linux environment while CLASSPATH is only used by Java ClassLoaders to load class files.

These were some notable difference between PATH vs CLASSPATH in Java and they are worth remembering to debug and troubleshoot Java related issues. 

How to set PATH and CLASSPATH in Windows and Unix
If you are familiar with DOS operating system and how to use command prompt in Windows or shell in Linux setting PATH and CLASSPATH is trivial exercise. Both PATH and CLASSPATH are environment variable and can be set using export in Linux and using set keyword in DOS and Windows as shown below:

Command to set PATH in Windows

set PATH=%PATH%;C:\Program Files\Java\JDK1.6.20\bin

Command to set PATH in UNIX/Linux

export PATH = ${PATH}:/opt/Java/JDK1.6.18/bin

Look at the difference between two commands, in Linux use colon(:) as separator and in Windows use semi-colon(;) as separator.

Command to set CLASSPATH in windows

set CLASSPATH=%CLASSPATH%;C:\Program Files\Java\JDK1.6.20\lib

Command to set CLASSPATH in Unix/Linux

export CLASSPATH= ${CLASSPATH}:/opt/Java/JDK1.6.18/lib

Also don't forget to include current directory, denoted by dot(.) to include in CLASSPATH, this will ensure that it will look first on current directory and if it found the class it will use that even if that class also exists in another directory which exists in CLASSPATH. 



Java Collections framework API is a unified architecture for representing and manipulating collections. The API contains Interfaces, Implementations & Algorithm to help java programmer in everyday programming. In nutshell, this API does 6 things at high level 
Reduces programming efforts. - Increases program speed and quality. 
Allows interoperability among unrelated APIs. 
Reduces effort to learn and to use new APIs. 
Reduces effort to design new APIs. 
Encourages & Fosters software reuse. 
To be specific, There are six collection java interfaces. The most basic interface is Collection. Three interfaces extend Collection: Set, List, and SortedSet. The other two collection interfaces, Map and SortedMap, do not extend Collection, as they represent mappings rather than true collections.

What is an Iterator?
Some of the collection classes provide traversal of their contents via a java.util.Iterator interface. This interface allows you to walk through a collection of objects, operating on each object in turn. Remember when using Iterators that they contain a snapshot of the collection at the time the Iterator was obtained; generally it is not advisable to modify the collection itself while traversing an Iterator.

What is the difference between java.util.Iterator and java.util.ListIterator?
Iterator : Enables you to traverse through a collection in the forward direction only, for obtaining or removing elements ListIterator : extends Iterator, and allows bidirectional traversal of list and also allows the modification of elements.

What is HashMap and Map? 
Map is Interface which is part of Java collections framework. This is to store Key Value pair, and Hashmap is class that implements that using hashing technique.

Difference between HashMap and HashTable? Compare Hashtable vs HashMap?
Both Hashtable & HashMap provide key-value access to data. The Hashtable is one of the original collection classes in Java (also called as legacy classes). HashMap is part of the new Collections Framework, added with Java 2, v1.2. There are several differences between HashMap and Hashtable in Java as listed below 
The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. (HashMap allows null values as key and value whereas Hashtable doesn’t allow nulls). 
HashMap does not guarantee that the order of the map will remain constant over time. But one of HashMap's subclasses is LinkedHashMap, so in the event that you'd want predictable iteration order (which is insertion order by default), you can easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you were using Hashtable. 
HashMap is non synchronized whereas Hashtable is synchronized. 
Iterator in the HashMap is fail-fast while the enumerator for the Hashtable isn't. So this could be a design consideration. 
What does synchronized means in Hashtable context?
Synchronized means only one thread can modify a hash table at one point of time. Any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released.

What is fail-fast property?

At high level - Fail-fast is a property of a system or software with respect to its response to failures. A fail-fast system is designed to immediately report any failure or condition that is likely to lead to failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly-flawed process. When a problem occurs, a fail-fast system fails immediately and visibly. Failing fast is a non-intuitive technique: "failing immediately and visibly" sounds like it would make your software more fragile, but it actually makes it more robust. Bugs are easier to find and fix, so fewer go into production. In Java, Fail-fast term can be related to context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object "structurally", a concurrent modification exception will be thrown. It is possible for other threads though to invoke "set" method since it doesn't modify the collection "structurally". However, if prior to calling "set", the collection has been modified structurally, "IllegalArgumentException" will be thrown.

Why doesn't Collection extend Cloneable and Serializable?

From Sun FAQ Page: Many Collection implementations (including all of the ones provided by the JDK) will have a public clone method, but it would be mistake to require it of all Collections. For example, what does it mean to clone a Collection that's backed by a terabyte SQL database? Should the method call cause the company to requisition a new disk farm? Similar arguments hold for serializable. If the client doesn't know the actual type of a Collection, it's much more flexible and less error prone to have the client decide what type of Collection is desired, create an empty Collection of this type, and use the addAll method to copy the elements of the original collection into the new one. Note on Some Important Terms 
Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released. 
Fail-fast is relevant from the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object "structurally”, a concurrent modification exception will be thrown. It is possible for other threads though to invoke "set" method since it doesn’t modify the collection "structurally”. However, if prior to calling "set", the collection has been modified structurally, "IllegalArgumentException" will be thrown. 

How can we make Hashmap synchronized?
HashMap can be synchronized by Map m = Collections.synchronizedMap(hashMap);

Where will you use Hashtable and where will you use HashMap?

There are multiple aspects to this decision: 1. The basic difference between a Hashtable and an HashMap is that, Hashtable is synchronized while HashMap is not. Thus whenever there is a possibility of multiple threads accessing the same instance, one should use Hashtable. While if not multiple threads are going to access the same instance then use HashMap. Non synchronized data structure will give better performance than the synchronized one. 2. If there is a possibility in future that - there can be a scenario when you may require to retain the order of objects in the Collection with key-value pair then HashMap can be a good choice. As one of HashMap's subclasses is LinkedHashMap, so in the event that you'd want predictable iteration order (which is insertion order by default), you can easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you were using Hashtable. Also if you have multiple thread accessing you HashMap then Collections.synchronizedMap() method can be leveraged. Overall HashMap gives you more flexibility in terms of possible future changes.

Difference between Vector and ArrayList? What is the Vector class? 

Vector & ArrayList both classes are implemented using dynamically resizable arrays, providing fast random access and fast traversal. ArrayList and Vector class both implement the List interface. Both the classes are member of Java collection framework, therefore from an API perspective, these two classes are very similar. However, there are still some major differences between the two. Below are some key differences 
Vector is a legacy class which has been retrofitted to implement the List interface since Java 2 platform v1.2 
Vector is synchronized whereas ArrayList is not. Even though Vector class is synchronized, still when you want programs to run in multithreading environment using ArrayList with Collections.synchronizedList() is recommended over Vector. 
ArrayList has no default size while vector has a default size of 10. 
The Enumerations returned by Vector's elements method are not fail-fast. Whereas ArraayList does not have any method returning Enumerations. 

What is the Difference between Enumeration and Iterator interface?

Enumeration and Iterator are the interface available in java.util package. The functionality of Enumeration interface is duplicated by the Iterator interface. New implementations should consider using Iterator in preference to Enumeration. Iterators differ from enumerations in following ways: 
Enumeration contains 2 methods namely hasMoreElements() & nextElement() whereas Iterator contains three methods namely hasNext(), next(),remove(). 
Iterator adds an optional remove operation, and has shorter method names. Using remove() we can delete the objects but Enumeration interface does not support this feature. 
Enumeration interface is used by legacy classes. Vector.elements() & Hashtable.elements() method returns Enumeration. Iterator is returned by all Java Collections Framework classes. java.util.Collection.iterator() method returns an instance of Iterator. 

Why Java Vector class is considered obsolete or unofficially deprecated? or Why should I always use ArrayList over Vector?

You should use ArrayList over Vector because you should default to non-synchronized access. Vector synchronizes each individual method. That's almost never what you want to do. Generally you want to synchronize a whole sequence of operations. Synchronizing individual operations is both less safe (if you iterate over a Vector, for instance, you still need to take out a lock to avoid anyone else changing the collection at the same time) but also slower (why take out a lock repeatedly when once will be enough)? Of course, it also has the overhead of locking even when you don't need to. It's a very flawed approach to have synchronized access as default. You can always decorate a collection using Collections.synchronizedList - the fact that Vector combines both the "resized array" collection implementation with the "synchronize every operation" bit is another example of poor design; the decoration approach gives cleaner separation of concerns. Vector also has a few legacy methods around enumeration and element retrieval which are different than the List interface, and developers (especially those who learned Java before 1.2) can tend to use them if they are in the code. Although Enumerations are faster, they don't check if the collection was modified during iteration, which can cause issues, and given that Vector might be chosen for its syncronization - with the attendant access from multiple threads, this makes it a particularly pernicious problem. Usage of these methods also couples a lot of code to Vector, such that it won't be easy to replace it with a different List implementation. Despite all above reasons Sun may never officially deprecate Vector class. (Read details Deprecate Hashtable and Vector)

What is an enumeration?

An enumeration is an interface containing methods for accessing the underlying data structure from which the enumeration is obtained. It is a construct which collection classes return when you request a collection of all the objects stored in the collection. It allows sequential access to all the elements stored in the collection.

What is the difference between Enumeration and Iterator?

The functionality of Enumeration interface is duplicated by the Iterator interface. Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects, where as using Iterator we can manipulate the objects also like adding and removing the objects. So Enumeration is used when ever we want to make Collection objects as Read-only.

Where will you use Vector and where will you use ArrayList?

The basic difference between a Vector and an ArrayList is that, vector is synchronized while ArrayList is not. Thus whenever there is a possibility of multiple threads accessing the same instance, one should use Vector. While if not multiple threads are going to access the same instance then use ArrayList. Non synchronized data structure will give better performance than the synchronized one.

What is the importance of hashCode() and equals() methods? How they are used in Java?

The java.lang.Object has two methods defined in it. 
They are - public boolean equals(Object obj) public int hashCode(). 
These two methods are used heavily when objects are stored in collections.
There is a contract between these two methods which should be kept in mind while overriding any of these methods. 
The Java API documentation describes it in detail. 
The hashCode() method returns a hash code value for the object.
This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable or java.util.HashMap. 
The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. The equals(Object obj) method indicates whether some other object is "equal to" this one. The equals method implements an equivalence relation on non-null object references: It is reflexive: for any non-null reference value x, x.equals(x) should return true. It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. For any non-null reference value x, x.equals(null) should return false. The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes. A practical Example of hashcode() & equals(): This can be applied to classes that need to be stored in Set collections. Sets use equals() to enforce non-duplicates, and HashSet uses hashCode() as a first-cut test for equality. Technically hashCode() isn't necessary then since equals() will always be used in the end, but providing a meaningful hashCode() will improve performance for very large sets or objects that take a long time to compare using equals().

What is the difference between Sorting performance of Arrays.sort() vs Collections.sort() ? Which one is faster? Which one to use and when?

Many developers are concerned about the performance difference between java.util.Array.sort() java.util.Collections.sort() methods. Both methods have same algorithm the only difference is type of input to them. Collections.sort() has a input as List so it does a translation of List to array and vice versa which is an additional step while sorting. So this should be used when you are trying to sort a list. Arrays.sort is for arrays so the sorting is done directly on the array. So clearly it should be used when you have a array available with you and you want to sort it.

What is java.util.concurrent BlockingQueue? How it can be used?

Java has implementation of BlockingQueue available since Java 1.5. Blocking Queue interface extends collection interface, which provides you power of collections inside a queue. Blocking Queue is a type of Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. A typical usage example would be based on a producer-consumer scenario. Note that a BlockingQueue can safely be used with multiple producers and multiple consumers. An ArrayBlockingQueue is a implementation of blocking queue with an array used to store the queued objects. The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. ArrayBlockingQueue requires you to specify the capacity of queue at the object construction time itself. Once created, the capacity cannot be increased. This is a classic "bounded buffer" (fixed size buffer), in which a fixed-sized array holds elements inserted by producers and extracted by consumers. Attempts to put an element to a full queue will result in the put operation blocking; attempts to retrieve an element from an empty queue will be blocked.

Set & List interface extend Collection, so Why doesn't Map interface extend Collection?


Though the Map interface is part of collections framework, it does not extend collection interface. This is by design, and the answer to this questions is best described in Sun's FAQ Page: This was by design. We feel that mappings are not collections and collections are not mappings. Thus, it makes little sense for Map to extend the Collection interface (or vice versa). If a Map is a Collection, what are the elements? The only reasonable answer is "Key-value pairs", but this provides a very limited (and not particularly useful) Map abstraction. You can't ask what value a given key maps to, nor can you delete the entry for a given key without knowing what value it maps to. Collection could be made to extend Map, but this raises the question: what are the keys? There's no really satisfactory answer, and forcing one leads to an unnatural interface. Maps can be viewed as Collections (of keys, values, or pairs), and this fact is reflected in the three "Collection view operations" on Maps (keySet, entrySet, and values). While it is, in principle, possible to view a List as a Map mapping indices to elements, this has the nasty property that deleting an element from the List changes the Key associated with every element before the deleted element. That's why we don't have a map view operation on Lists.

Which implementation of the List interface provides for the fastest insertion of a new element into the middle of the list? 


a. Vector b. ArrayList c. LinkedList ArrayList and Vector both use an array to store the elements of the list. When an element is inserted into the middle of the list the elements that follow the insertion point must be shifted to make room for the new element. The LinkedList is implemented using a doubly linked list; an insertion requires only the updating of the links at the point of insertion. Therefore, the LinkedList allows for fast insertions and deletions.

What is the difference between ArrayList and LinkedList? (ArrayList vs LinkedList.) 

java.util.ArrayList and java.util.LinkedList are two Collections classes used for storing lists of object references Here are some key differences: 
ArrayList uses primitive object array for storing objects whereas LinkedList is made up of a chain of nodes. Each node stores an element and the pointer to the next node. A singly linked list only has pointers to next. A doubly linked list has a pointer to the next and the previous element. This makes walking the list backward easier. 
ArrayList implements the RandomAccess interface, and LinkedList does not. The commonly used ArrayList implementation uses primitive Object array for internal storage. Therefore an ArrayList is much faster than a LinkedList for random access, that is, when accessing arbitrary list elements using the get method. Note that the get method is implemented for LinkedLists, but it requires a sequential scan from the front or back of the list. This scan is very slow. For a LinkedList, there's no fast way to access the Nth element of the list. 
Adding and deleting at the start and middle of the ArrayList is slow, because all the later elements have to be copied forward or backward. (Using System.arrayCopy()) Whereas Linked lists are faster for inserts and deletes anywhere in the list, since all you do is update a few next and previous pointers of a node. 
Each element of a linked list (especially a doubly linked list) uses a bit more memory than its equivalent in array list, due to the need for next and previous pointers. 
ArrayList may also have a performance issue when the internal array fills up. The arrayList has to create a new array and copy all the elements there. The ArrayList has a growth algorithm of (n*3)/2+1, meaning that each time the buffer is too small it will create a new one of size (n*3)/2+1 where n is the number of elements of the current buffer. Hence if we can guess the number of elements that we are going to have, then it makes sense to create a arraylist with that capacity during object creation (using construtor new ArrayList(capacity)). Whereas LinkedLists should not have such capacity issues. 
Where will you use ArrayList and Where will you use LinkedList? Or Which one to use when (ArrayList / LinkedList).

Below is a snippet from SUN's site. The Java SDK contains 2 implementations of the List interface - ArrayList and LinkedList. If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList. These operations require constant-time in a LinkedList and linear-time in an ArrayList. But you pay a big price in performance. Positional access requires linear-time in a LinkedList and constant-time in an ArrayList.

What is performance of various Java collection implementations/algorithms? What is Big 'O' notation for each of them ?

Each java collection implementation class have different performance for different methods, which makes them suitable for different programming needs. 

Performance of Map interface implementations
Hashtable
An instance of Hashtable has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a "hash collision", a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. The initial capacity and load factor parameters are merely hints to the implementation. The exact details as to when and whether the rehash method is invoked are implementation-dependent. 
HashMap 
This implementation provides constant-time [ Big O Notation is O(1) ] performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the "capacity" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. 
TreeMap
The TreeMap implementation provides guaranteed log(n) [ Big O Notation is O(log N) ] time cost for the containsKey, get, put and remove operations. 
LinkedHashMap
A linked hash map has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashMap. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashMap, as iteration times for this class are unaffected by capacity.


Performance of Set interface implementations


HashSet
The HashSet class offers constant-time [ Big O Notation is O(1) ] performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the "capacity" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. 
TreeSet
The TreeSet implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains). 
LinkedHashSet
A linked hash set has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashSet. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashSet, as iteration times for this class are unaffected by capacity.

Performance of List interface implementations
LinkedList
- Performance of get and remove methods is linear time [ Big O Notation is O(n) ] - Performance of add and Iterator.remove methods is constant-time [ Big O Notation is O(1) ] 
ArrayList
- The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. [ Big O Notation is O(1) ] - The add operation runs in amortized constant time [ Big O Notation is O(1) ] , but in worst case (since the array must be resized and copied) adding n elements requires linear time [ Big O Notation is O(n) ] - Performance of remove method is linear time [ Big O Notation is O(n) ] - All of the other operations run in linear time [ Big O Notation is O(n) ]. The constant factor is low compared to that for the LinkedList implementation. 


Collections Framework Enhancements      
 
This page summarizes enhancements to the collections framework in Java SE 6. 
These new collection interfaces are provided:

Deque - a double ended queue, supporting element insertion and removal at both ends. Extends the Queue interface.
BlockingDeque - a Deque with operations that wait for the deque to become non-empty when retrieving an element, and wait for space to become available in the deque when storing an element. Extends both the Deque and BlockingQueue interfaces. (This interface is part of java.util.concurrent.)
NavigableSet - a SortedSet extended with navigation methods reporting closest matches for given search targets. A NavigableSet may be accessed and traversed in either ascending or descending order. This interface is intended to supersede the SortedSet interface.
NavigableMap - a SortedMap extended with navigation methods returning the closest matches for given search targets. A NavigableMap may be accessed and traversed in either ascending or descending key order. This interface is intended to supersede the SortedMap interface.
ConcurrentNavigableMap - a ConcurrentMap that is also a NavigableMap. (This interface is part of java.util.concurrent.)

The following concrete implementation classes have been added:

ArrayDeque - efficient resizable-array implementation of the Deque interface.
ConcurrentSkipListSet - concurrent scalable skip list implementation of the NavigableSet interface.
ConcurrentSkipListMap - concurrent scalable skip list implementation of the ConcurrentNavigableMap interface.
LinkedBlockingDeque - concurrent scalable optionally bounded FIFO blocking deque backed by linked nodes.
AbstractMap.SimpleEntry - simple mutable implementation of Map.Entry
AbstractMap.SimpleImmutableEntry - simple immutable implementation of Map.Entry
These existing classes have been retrofitted to implement new interfaces:

LinkedList - retrofitted to implement the Deque interface.
TreeSet - retrofitted to implement the NavigableSet interface.
TreeMap - retrofitted to implement the NavigableMap interface.
Two new methods were added to the Collections utility class:

newSetFromMap(Map) - creates a general purpose Set implementation from a general purpose Map implementation. 
There is no IdentityHashSet class, but instead, just use

Set<Object> identityHashSet=
    Collections.newSetFromMap(
        new IdentityHashMap<Object, Boolean>());
asLifoQueue(Deque) - returns a view of a Deque as a Last-in-first-out (Lifo) Queue.
The Arrays utility class now has methods copyOf and copyOfRange that can efficiently resize, truncate, or copy subarrays for arrays of all types. 
Before:

int[] newArray = new int[newLength];
System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);
After:

int[] newArray = Arrays.copyOf(a, newLength);


This method checks if some other object passed to it as an argument is equal to the object on which this method is invoked. The default implementation of this method in Object class simply checks if two object references x and y refer to the same object. i.e. It checks if x == y. This particular comparison is also known as "shallow comparison". However, the classes providing their own implementations of the equals method are supposed to perform a "deep comparison"; by actually comparing the relevant data members. Since Object class has no data members that define its state, it simply performs shallow comparison.

The equals method implements an equivalence relation:
-It is reflexive: for any reference value x, x.equals(x) should return true.
-It is symmetric: for any reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.
-It is transitive: for any reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.
-It is consistent: for any reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the object is modified.
For any non-null reference value x, x.equals(null) should return false.

public int hashCode()

The general contract of hashCode is:
-Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.

-If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.
-It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.

Hashcode example

public class HashCodeString {
public static void main(String args[]) {
Integer j = new Integer(4);
Long k = new Long(4);
Integer v = new Integer(3);
System.out.println("false is returned: " + j.equals(k)); // Result - false
System.out.println("Hash code of number 4 is: " + j.hashCode() //Result 4
+ "\nHash code of number 4 is: " + k.hashCode()); // 4
System.out.println("Method returns three: " + v.hashCode()); // 3
String baadshah = "latter in time there will be my empire every where";
System.out.println("Corresponding hash code value returned is: "
+ baadshah.hashCode()); // Result 342564105
}

}



Covariant Return Type
The covariant return type specifies that the return type may vary in the same direction as the subclass. Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. Let's take a simple example:  

Note: If you are beginner to java, skip this topic and return to it after OOPs concepts.

--------------------------------------------------------------------------------

Simple example of Covariant Return Type
class A{
A get(){return this;}
}

class B extends A{
B get(){return this;}
void message(){System.out.println("welcome to covariant return type");}

public static void main(String args[]){
new B().get().message();
}
}

 

Output:welcome to covariant return type

As you can see in the above example, the return type of the get() method of A class is A but the return type of the get() method of B class is B. Both methods have different return type but it is method overriding. This is known as covariant return type.  





Different ways to create objects in Java
There are four different ways (I really don’t know is there a fifth way to do this) to create objects in java:

1. Using new keyword
This is the most common way to create an object in java. I read somewhere that almost 99% of objects are created in this way.

MyObject object = new MyObject();

2. Using Class.forName()
If we know the name of the class & if it has a public default constructor we can create an object in this way.

MyObject object = (MyObject) Class.forName("subin.rnd.MyObject").newInstance(); 

3. Using clone()
The clone() can be used to create a copy of an existing object.

MyObject anotherObject = new MyObject(); 
MyObject object = anotherObject.clone();

4. Using object deserialization
Object deserialization is nothing but creating an object from its serialized form.

ObjectInputStream inStream = new ObjectInputStream(anInputStream ); 
MyObject object = (MyObject) inStream.readObject();

Now you know how to create an object. But its advised to create objects only when it is necessary to do so.

Exceptions Interview Questions 
Q1) What is an Exception? 

Ans) The exception is said to be thrown whenever an exceptional event occurs in java which signals that something is not correct with the code written and may give unexpected result. An exceptional event is a occurrence of condition which alters the normal program flow. Exceptional handler is the code that does something about the exception.
 
Q2) Exceptions are defined in which java package? 

Ans)All the exceptions are subclasses of java.lang.Exception 
 
Q3) How are the exceptions handled in java? 

Ans)When an exception occurs the execution of the program is transferred to an appropriate exception handler.The try-catch-finally block is used to handle the exception.
The code in which the exception may occur is enclosed in a try block, also called as a guarded region.
The catch clause matches a specific exception to a block of code which handles that exception.
And the clean up code which needs to be executed no matter the exception occurs or not is put inside the finally block
 
Q4) Explain the exception hierarchy in java. 

Ans) The hierarchy is as follows: 

 

Throwable is a parent class off all Exception classes. They are two types of Exceptions: Checked exceptions and UncheckedExceptions. Both type of exceptions extends Exception class. 
 
Q5) What is Runtime Exception or unchecked exception? 

Ans) Runtime exceptions represent problems that are the result of a programming problem. Such problems include arithmetic exceptions, such as dividing by zero; pointer exceptions, such as trying to access an object through a null reference; and indexing exceptions, such as attempting to access an array element through an index that is too large or too small. Runtime exceptions need not be explicitly caught in try catch block as it can occur anywhere in a program, and in a typical one they can be very numerous. Having to add runtime exceptions in every method declaration would reduce a program's clarity. Thus, the compiler does not require that you catch or specify runtime exceptions (although you can). The solution to rectify is to correct the programming logic where the exception has occurred or provide a check.
 
Q6) What is checked exception? 

Ans) Checked exception are the exceptions which forces the programmer to catch them explicitly in try-catch block. It is a subClass of Exception. Example: IOException. 
 
Q7) What is difference between Error and Exception? 

Ans) An error is an irrecoverable condition occurring at runtime. Such as OutOfMemory error. These JVM errors and you can not repair them at runtime.Though error can be caught in catch block but the execution of application will come to a halt and is not recoverable.

While exceptions are conditions that occur because of bad input etc. e.g. FileNotFoundException will be thrown if the specified file does not exist. Or a NullPointerException will take place if you try using a null reference. In most of the cases it is possible to recover from an exception (probably by giving user a feedback for entering proper values etc.) 
 
Q8) What is difference between ClassNotFoundException and NoClassDefFoundError? 

Ans) A ClassNotFoundException is thrown when the reported class is not found by the ClassLoader in the CLASSPATH. It could also mean that the class in question is trying to be loaded from another class which was loaded in a parent classloader and hence the class from the child classloader is not visible.

Consider if NoClassDefFoundError occurs which is something like

java.lang.NoClassDefFoundError

src/com/TestClass 

does not mean that the TestClass class is not in the CLASSPATH. It means that the class TestClass was found by the ClassLoader however when trying to load the class, it ran into an error reading the class definition. This typically happens when the class in question has static blocks or members which use a Class that's not found by the ClassLoader. So to find the culprit, view the source of the class in question (TestClass in this case) and look for code using static blocks or static members. 
 
Q9) What is throw keyword?

Ans) Throw keyword is used to throw the exception manually. It is mainly used when the program fails to satisfy the given condition and it wants to warn the application.The exception thrown should be subclass of Throwable. 

  public void parent(){
  try{
   child();
  }catch(MyCustomException e){ }
  }


  public void child{
  String iAmMandatory=null;
   if(iAmMandatory == null){
    throw (new MyCustomException("Throwing exception using throw keyword");
   }
  } 

 
Q10) What is use of throws keyword?

Ans) If the function is not capable of handling the exception then it can ask the calling method to handle it by simply putting the throws clause at the function declaration.

  public void parent(){
  try{
   child();
  }catch(MyCustomException e){ }
  }


  public void child throws MyCustomException{
   //put some logic so that the exception occurs.
  } 
 
Q11) What are the possible combination to write try, catch finally block? 

Ans) 


1) try{ 

//lines of code that may throw an exception

}catch(Exception e){

//lines of code to handle the exception thrown in try block

}finally{

//the clean code which is executed always no matter the exception occurs or not.

}



2 try{

}finally{}

3 try{

}catch(Exception e){

//lines of code to handle the exception thrown in try block

}



The catch blocks must always follow the try block. If there are more than one catch blocks they all must follow each other without any block in between. The finally block must follow the catch block if one is present or if the catch block is absent the finally block must follow the try block.
 
Q12) How to create custom Exception?

Ans) To create you own exception extend the Exception class or any of its subclasses. 

e.g.

1 class New1Exception extends Exception { } // this will create Checked Exception 

2 class NewException extends IOExcpetion { } // this will create Checked exception

3 class NewException extends NullPonterExcpetion { } // this will create UnChecked exception
 
Q13) When to make a custom checked Exception or custom unchecked Exception? 

Ans) If an application can reasonably be expected to recover from an exception, make it a checked exception. If an application cannot do anything to recover from the exception, make it an unchecked exception.
 
Q14)What is StackOverflowError?

Ans) The StackOverFlowError is an Error Object thorwn by the Runtime System when it Encounters that your application/code has ran out of the memory. It may occur in case of recursive methods or a large amount of data is fetched from the server and stored in some object. This error is generated by JVM. 

e.g. void swap(){ 

swap();

}
 
Q15) Why did the designers decide to force a method to specify all uncaught checked exceptions that can be thrown within its scope?

Ans) Any Exception that can be thrown by a method is part of the method's public programming interface. Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them. These exceptions are as much a part of that method's programming interface as its parameters and return value.
 

Q16) Once the control switches to the catch block does it return back to the try block to execute the balance code? 

Ans) No. Once the control jumps to the catch block it never returns to the try block but it goes to finally block(if present). 
 
Q17) Where is the clean up code like release of resources is put in try-catch-finally block and why? 

Ans) The code is put in a finally block because irrespective of try or catch block execution the control will flow to finally block. Typically finally block contains release of connections, closing of result set etc. 
 
Q18) Is it valid to have a try block without catch or finally?

Ans) NO. This will result in a compilation error. The try block must be followed by a catch or a finally block. It is legal to omit the either catch or the finally block but not both. 

e.g. The following code is illegal.

try{
int i =0; 
}
int a = 2;
System.out.println(“a = “+a);
 
Q19) Is it valid to place some code in between try the catch/finally block that follows it?

Ans) No. There should not be any line of code present between the try and the catch/finally block. e.g. The following code is wrong.

try{}
String str = “ABC”;
System.out.println(“str = “+str);
catch(Exception e){}

 
Q20) What happens if the exception is never caught and throws down the method stack? 

Ans) If the exception is not caught by any of the method in the method’s stack till you get to the main() method, the main method throws that exception and the JVM halts its execution. 
 
Q21) How do you get the descriptive information about the Exception occurred during the program execution?

Ans) All the exceptions inherit a method printStackTrace() from the Throwable class. This method prints the stack trace from where the exception occurred. It prints the most recently entered method first and continues down, printing the name of each method as it works its way down the call stack from the top. 
 
Q22) Can you catch more than one exceptions in a single catch block? 

Ans)Yes. If the exception class specified in the catch clause has subclasses, any exception object that is a subclass of the specified Exception class will be caught by that single catch block. 

E.g.. 

try {

// Some code here that can throw an IOException

}

catch (IOException e) {

e.printStackTrace();

}

The catch block above will catch IOException and all its subclasses e.g. FileNotFoundException etc. 
 
Q23)Why is not considered as a good practice to write a single catchall handler to catch all the exceptions?

Ans) You can write a single catch block to handle all the exceptions thrown during the program execution as follows : 

try {

// code that can throw exception of any possible type

}catch (Exception e) {

e.printStackTrace();

}

If you use the Superclass Exception in the catch block then you will not get the valuable information about each of the exception thrown during the execution, though you can find out the class of the exception occurred. Also it will reduce the readability of the code as the programmer will not understand what is the exact reason for putting the try-catch block.
 
Q24) What is exception matching?

Ans) Exception matching is the process by which the the jvm finds out the matching catch block for the exception thrown from the list of catch blocks. When an exception is thrown, Java will try to find by looking at the available catch clauses in the top down manner. If it doesn't find one, it will search for a handler for a supertype of the exception. If it does not find a catch clause that matches a supertype for the exception, then the exception is propagated down the call stack. This process is called exception matching.
 
Q25) What happens if the handlers for the most specific exceptions is placed above the more general exceptions handler?

Ans) Compilation fails. The catch block for handling the most specific exceptions must always be placed above the catch block written to handle the more general exceptions. 

e.g. The code below will not compile.

1 try { 

// code that can throw IOException or its subtypes 

} catch (IOException e) { 

// handles IOExceptions and its subtypes 

} catch (FileNotFoundException ex) { 

// handle FileNotFoundException only 

} 

The code below will compile successfully :- 

try { 
// code that can throw IOException or its subtypes 
} catch (FileNotFoundException ex) { 
// handles IOExceptions and its subtypes 
} catch (IOException e){ 
// handle FileNotFoundException only 
} 

 
Q26) Does the order of the catch blocks matter if the Exceptions caught by them are not subtype or supertype of each other? 

Ans) No. If the exceptions are siblings in the Exception class’s hierarchy i.e. If one Exception class is not a subtype or supertype of the other, then the order in which their handlers(catch clauses) are placed does not matter.
 
Q27) What happens if a method does not throw an checked Exception directly but calls a method that does? What does 'Ducking' the exception mean? 

Ans) If a method does not throw an checked Exception directly but calls a method that throws an exception then the calling method must handle the throw exception or declare the exception in its throws clause. If the calling method does not handle and declares the exception, the exceptions is passed to the next method in the method stack. This is called as ducking the exception down the method stack. 

e.g. The code below will not compile as the getCar() method has not declared the CarNotFoundException which is thrown by the getColor () method.

void getCar() {

getColor();

}

void getColor () {

throw new CarNotFoundException();

}

Fix for the above code is

void getCar() throws CarNotFoundException {

getColor();

}

void getColor () {

throw new CarNotFoundException();

}
 
Q28) Is an empty catch block legal?

Ans) Yes you can leave the catch block without writing any actual code to handle the exception caught. 

e.g. The code below is legal but not appropriate, as in this case you will nt get any information about the exception thrown.

try{

//code that may throw the FileNotFoundException

}catch(FileNotFound eFnf){

//no code to handle the FileNotFound exception

}

 
 
Q29)Can a catch block throw the exception caught by itself? 

Ans) Yes. This is called rethrowing of the exception by catch block. 

e.g. the catch block below catches the FileNotFound exception and rethrows it again.

void checkEx() throws FileNotFoundException {

try{

//code that may throw the FileNotFoundException

}catch(FileNotFound eFnf){

throw FileNotFound();

}

}
 



1.What is an exception? 
An exception is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions.

2.What is error? 
An Error indicates that a non-recoverable condition has occurred that should not be caught. Error, a subclass of Throwable, is intended for drastic problems, such as OutOfMemoryError, which would be reported by the JVM itself.


3.Which is superclass of Exception? 
"Throwable", the parent class of all exception related classes. 


4.What are the advantages of using exception handling? 
Exception handling provides the following advantages over "traditional" error management techniques: 

Separating Error Handling Code from "Regular" Code. 
Propagating Errors Up the Call Stack. 
Grouping Error Types and Error Differentiation. 

5.What are the types of Exceptions in Java 
There are two types of exceptions in Java, unchecked exceptions and checked exceptions. 

Checked exceptions: A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses. Each method must either handle all checked exceptions by supplying a catch clause or list each unhandled checked exception as a thrown exception. 
Unchecked exceptions: All Exceptions that extend the RuntimeException class are unchecked exceptions. Class Error and its subclasses also are unchecked. 

6.Why Errors are Not Checked? 
A unchecked exception classes which are the error classes (Error and its subclasses) are exempted from compile-time checking because they can occur at many points in the program and recovery from them is difficult or impossible. A program declaring such exceptions would be pointlessly.


7.Why Runtime Exceptions are Not Checked? 
The runtime exception classes (RuntimeException and its subclasses) are exempted from compile-time checking because, in the judgment of the designers of the Java programming language, having to declare such exceptions would not aid significantly in establishing the correctness of programs. Many of the operations and constructs of the Java programming language can result in runtime exceptions. The information available to a compiler, and the level of analysis the compiler performs, are usually not sufficient to establish that such run-time exceptions cannot occur, even though this may be obvious to the programmer. Requiring such exception classes to be declared would simply be an irritation to programmers.


8.Explain the significance of try-catch blocks? 
Whenever the exception occurs in Java, we need a way to tell the JVM what code to execute. To do this, we use the try and catch keywords. The try is used to define a block of code in which exceptions may occur. One or more catch clauses match a specific exception to a block of code that handles it.




9.What is the use of finally block? People who read this, also read:-
Tibco Interview Questions 
XML Questions 
SCMAD Certification 
Hibernate Vs iBatis 
Tibco Interview Questions 
 
The finally block encloses code that is always executed at some point after the try block, whether an exception was thrown or not. This is right place to close files, release your network sockets, connections, and perform any other cleanup your code requires.

Note: If the try block executes with no exceptions, the finally block is executed immediately after the try block completes. It there was an exception thrown, the finally block executes immediately after the proper catch block completes


10.What if there is a break or return statement in try block followed by finally block? 
If there is a return statement in the try block, the finally block executes right after the return statement encountered, and before the return executes.




Question1: What is IOC or inversion of control?
Answer: This Spring interview question is first step towards Spring framework and many interviewer starts Spring interview from this question. As the name implies Inversion of control means now we have inverted the control of creating the object from our own using new operator to container or framework. Now it’s the responsibility of container to create object as required. We maintain one xml file where we configure our components, services, all the classes and their property. We just need to mention which service is needed by which component and container will create the object for us. This concept is known as dependency injection because all object dependency (resources) is injected into it by framework.


Example:
  <bean id="createNewStock" class="springexample.stockMarket.CreateNewStockAccont"> 
        <property name="newBid"/> 
  </bean>
In this example CreateNewStockAccont class contain getter and setter for newBid and container will instantiate newBid and set the value automatically when it is used. This whole process is also called wiring in Spring and by using annotation it can be done automatically by Spring, refereed as auto-wiring of bean in Spring.




Read more: http://javarevisited.blogspot.com/2011/09/spring-interview-questions-answers-j.
What is Bean Factory ?

A BeanFactory is like a factory class that contains a collection of beans. The BeanFactory holds Bean Definitions of multiple beans within itself and then instantiates the bean whenever asked for by clients.

BeanFactory is able to create associations between collaborating objects as they are instantiated. This removes the burden of configuration from bean itself and the beans client. 
BeanFactory also takes part in the life cycle of a bean, making calls to custom initialization and destruction methods. 
The BeanFactory is the actual container which instantiates, configures, and manages a number of beans. These beans typically collaborate with one another, and thus have dependencies between themselves. 



10. What is Application Context?

A bean factory is fine to simple applications, but to take advantage of the full power of the Spring framework, you may want to move up to Springs more advanced container, the application context. On the surface, an application context is same as a bean factory.Both load bean definitions, wire beans together, and dispense beans upon request. But it also provides: 

A means for resolving text messages, including support for internationalization. 
A generic way to load file resources. 
Events to beans that are registered as listeners. 

As opposed to the BeanFactory, which will often be created programmatically, ApplicationContexts can be created declaratively using a ContextLoader. You can register an ApplicationContext using the ContextLoaderListener as shown below in the web.xml file. The Spring context listener provides more flexibility in terms of how an application is wired together. It uses the application's Spring configuration to determine what object to instantiate and loads the objects into the application context used by the servlet container.

<web-app>   .....   <listener>      
<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>   </listener>   .... </web-app>

By default, it looks for a file named applicationContext.xml file in WEB-INF folder. But, you can configure the org.springframework.web.context.ContextLoaderListener class to use a context parameter called contextConfigLocation to determine the location of the Spring configuration file. The context parameter is configured using the context-parameter element. The context-param element has two children that specify parameters and their values. The param-name element specifies the parameter's name. The param-value element specifies the parameter's value.

<web-app>   ...   <context-param>     <param-name>contextConfigLocation</param-name>     <param-value>WEB-INF/beans.xml</param-value>   </context-param>     <listener>      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>   </listener>   ... </web-app> 



11. What is the difference between Bean Factory and Application Context ?  

On the surface, an application context is same as a bean factory. But application context offers much more.. 


Application contexts provide a means for resolving text messages, including support for i18n of those messages. 


Application contexts provide a generic way to load file resources, such as images. 


Application contexts can publish events to beans that are registered as listeners. 


Certain operations on the container or beans in the container, which have to be handled in a programmatic fashion with a bean factory, can be handled declaratively in an application context. 


ResourceLoader support: Spring’s Resource interface us a flexible generic abstraction for handling low-level resources. An application context itself is a ResourceLoader, Hence provides an application with access to deployment-specific Resource instances. 


MessageSource support: The application context implements MessageSource, an interface used to obtain localized messages, with the actual implementation being pluggable 2ee.html#ixzz2ZBzybCHx

1.  What is IOC (or Dependency Injection)? 
The basic concept of the Inversion of Control pattern (also known as dependency injection) is that you do not create your objects but describe how they should be created. You don't directly connect your components and services together in code but describe which services are needed by which components in a configuration file. A container (in the case of the Spring framework, the IOC container) is then responsible for hooking it all up.

i.e., Applying IoC, objects are given their dependencies at creation time by some external entity that coordinates each object in the system. That is, dependencies are injected into objects. So, IoC means an inversion of responsibility with regard to how an object obtains references to collaborating objects. 

2. What are the different types of IOC (dependency injection) ? 


There are three types of dependency injection: 

Constructor Injection (e.g. Pico container, Spring etc): Dependencies are provided as constructor parameters. 
Setter Injection (e.g. Spring): Dependencies are assigned through JavaBeans properties (ex: setter methods). 
Interface Injection (e.g. Avalon): Injection is done through an interface.

Note: Spring supports only Constructor and Setter Injection



3. What are the benefits of IOC (Dependency Injection)?


Benefits of IOC (Dependency Injection) are as follows: 

Minimizes the amount of code in your application. With IOC containers you do not care about how services are created and how you get references to the ones you need. You can also easily add additional services by adding a new constructor or a setter method with little or no extra configuration.

Make your application more testable by not requiring any singletons or JNDI lookup mechanisms in your unit test cases. IOC containers make unit testing and switching implementations very easy by manually allowing you to inject your own objects into the object under test.

Loose coupling is promoted with minimal effort and least intrusive mechanism. The factory design pattern is more intrusive because components or services need to be requested explicitly whereas in IOC the dependency is injected into requesting piece of code. Also some containers promote the design to interfaces not to implementations design concept by encouraging managed objects to implement a well-defined service interface of your own.

IOC containers support eager instantiation and lazy loading of services. Containers also provide support for instantiation of managed objects, cyclical dependencies, life cycles management, and dependency resolution between managed objects etc.


Don't Miss... 
Spring Certification article 
Spring Basic Tutorial 
JSF Basic Tutorial 
JSF-Spring2.0 Integration 
Spring-iBatis Integration 
 
4.  What is Spring ?

Spring is an open source framework created to address the complexity of enterprise application development. One of the chief advantages of the Spring framework is its layered architecture, which allows you to be selective about which of its components you use while also providing a cohesive framework for J2EE application development. 



5. What are the advantages of Spring framework?

The advantages of Spring are as follows: 

Spring has layered architecture. Use what you need and leave you don't need now. 
Spring Enables POJO Programming. There is no behind the scene magic here. POJO programming enables continuous integration and testability. 
Dependency Injection and Inversion of Control Simplifies JDBC 
Open source and no vendor lock-in. 

6. What are features of Spring ?


Lightweight:
spring is lightweight when it comes to size and transparency. The basic version of spring framework is around 1MB. And the processing overhead is also very negligible.

Inversion of control (IOC):
Loose coupling is achieved in spring using the technique Inversion of Control. The objects give their dependencies instead of creating or looking for dependent objects.

Aspect oriented (AOP):
Spring supports Aspect oriented programming and enables cohesive development by separating application business logic from system services.

Container:
Spring contains and manages the life cycle and configuration of application objects.

MVC Framework:
Spring comes with MVC web application framework, built on core Spring functionality. This framework is highly configurable via strategy interfaces, and accommodates multiple view technologies like JSP, Velocity, Tiles, iText, and POI. But other frameworks can be easily used instead of Spring MVC Framework.

Transaction Management:
Spring framework provides a generic abstraction layer for transaction management. This allowing the developer to add the pluggable transaction managers, and making it easy to demarcate transactions without dealing with low-level issues. Spring's transaction support is not tied to J2EE environments and it can be also used in container less environments.

JDBC Exception Handling: 
The JDBC abstraction layer of the Spring offers a meaningful exception hierarchy, which simplifies the error handling strategy. Integration with Hibernate, JDO, and iBATIS: Spring provides best Integration services with Hibernate, JDO and iBATIS


Question 2: Explain Bean-LifeCycle.

Ans: Spring framework is based on IOC so we call it as IOC container also So Spring beans reside inside the IOC container. Spring beans are nothing but Plain old java object (POJO).
Following steps explain their life cycle inside container.
1. Container will look the bean definition inside configuration file (e.g. bean.xml).
2 using reflection container will create the object and if any property is defined inside the bean definition then it will also be set.
3. If the bean implements the BeanNameAware interface, the factory calls setBeanName() passing the bean’s ID.
4. If the bean implements the BeanFactoryAware interface, the factory calls setBeanFactory(), passing an instance of itself.
5. If there are any BeanPostProcessors associated with the bean, their post- ProcessBeforeInitialization() methods will be called before the properties for the Bean are set.
6. If an init() method is specified for the bean, it will be called.
7. If the Bean class implements the DisposableBean interface, then the method destroy() will be called when the Application no longer needs the bean reference.
8. If the Bean definition in the Configuration file contains a 'destroy-method' attribute, then the corresponding method definition in the Bean class will be called.


Question 3: what is Bean Factory, have you used XMLBeanFactory?
Ans: BeanFactory is factory Pattern which is based on IOC design principles.it is used to make a clear separation between application configuration and dependency from actual code.
XmlBeanFactory is one of the implementation of bean Factory which we have used in our project.
org.springframework.beans.factory.xml.XmlBeanFactory is used to create bean instance defined in our xml file.
BeanFactory factory = new XmlBeanFactory(new FileInputStream("beans.xml"));
Or
ClassPathResource resorce = new ClassPathResource("beans.xml"); 
XmlBeanFactory factory = new XmlBeanFactory(resorce); 




Read more: http://javarevisited.blogspot.com/2011/09/spring-interview-questions-answers-j2ee.html#ixzz2a9e60Xe8

